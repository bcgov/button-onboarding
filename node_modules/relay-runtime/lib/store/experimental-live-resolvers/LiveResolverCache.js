/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 * @format
 * @oncall relay
 */

'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/createForOfIteratorHelper"));
var recycleNodesInto = require('../../util/recycleNodesInto');
var _require = require('../../util/RelayConcreteNode'),
  RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;
var _require2 = require('../ClientID'),
  generateClientID = _require2.generateClientID,
  generateClientObjectClientID = _require2.generateClientObjectClientID;
var RelayModernRecord = require('../RelayModernRecord');
var _require3 = require('../RelayModernSelector'),
  createNormalizationSelector = _require3.createNormalizationSelector;
var RelayRecordSource = require('../RelayRecordSource');
var _require4 = require('../RelayResponseNormalizer'),
  normalize = _require4.normalize;
var _require5 = require('../RelayStoreUtils'),
  RELAY_RESOLVER_ERROR_KEY = _require5.RELAY_RESOLVER_ERROR_KEY,
  RELAY_RESOLVER_INVALIDATION_KEY = _require5.RELAY_RESOLVER_INVALIDATION_KEY,
  RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS = _require5.RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS,
  RELAY_RESOLVER_SNAPSHOT_KEY = _require5.RELAY_RESOLVER_SNAPSHOT_KEY,
  RELAY_RESOLVER_VALUE_KEY = _require5.RELAY_RESOLVER_VALUE_KEY,
  getStorageKey = _require5.getStorageKey;
var getOutputTypeRecordIDs = require('./getOutputTypeRecordIDs');
var isLiveStateValue = require('./isLiveStateValue');
var _require6 = require('./LiveResolverSuspenseSentinel'),
  isSuspenseSentinel = _require6.isSuspenseSentinel;
var invariant = require('invariant');
var warning = require("fbjs/lib/warning");

// When this experiment gets promoted to stable, these keys will move into
// `RelayStoreUtils`.
var RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY = '__resolverLiveStateSubscription';
var RELAY_RESOLVER_LIVE_STATE_VALUE = '__resolverLiveStateValue';
var RELAY_RESOLVER_LIVE_STATE_DIRTY = '__resolverLiveStateDirty';
var RELAY_RESOLVER_RECORD_TYPENAME = '__RELAY_RESOLVER__';

/**
 * An experimental fork of store/ResolverCache.js intended to let us experiment
 * with Live Resolvers.
 */

function addDependencyEdge(edges, from, to) {
  var set = edges.get(from);
  if (!set) {
    set = new Set();
    edges.set(from, set);
  }
  set.add(to);
}
var LiveResolverCache = /*#__PURE__*/function () {
  // Flag indicating that Live Resolver updates are being batched.
  // Lazily created record source for batched Live Resolver updates.

  function LiveResolverCache(getRecordSource, store) {
    this._resolverIDToRecordIDs = new Map();
    this._recordIDToResolverIDs = new Map();
    this._getRecordSource = getRecordSource;
    this._store = store;
    this._handlingBatch = false;
    this._liveResolverBatchRecordSource = null;
  }
  var _proto = LiveResolverCache.prototype;
  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
    var recordSource = this._getRecordSource();

    // NOTE: Be very careful with `record` in this scope. After `evaluate` has
    // been called, the `record` we have here may have been replaced in the
    // Relay store with a new record containing new information about nested
    // resolvers on this parent record.
    var record = expectRecord(recordSource, recordID);
    var storageKey = getStorageKey(field, variables);
    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);
    var updatedDataIDs;
    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {
      var _linkedID;
      // Cache miss; evaluate the selector and store the result in a new record:

      if (linkedRecord != null) {
        // Clean up any existing subscriptions before creating the new subscription
        // to avoid being double subscribed, or having a dangling subscription in
        // the event of an error during subscription.
        this._maybeUnsubscribeFromLiveState(linkedRecord);
      }
      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);
      linkedRecord = RelayModernRecord.create(linkedID, RELAY_RESOLVER_RECORD_TYPENAME);
      var evaluationResult = evaluate();
      if (field.kind === RELAY_LIVE_RESOLVER) {
        if (evaluationResult.resolverResult != undefined) {
          if (process.env.NODE_ENV !== "production") {
            !isLiveStateValue(evaluationResult.resolverResult) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected the @live Relay Resolver backing the field "%s" to return a value ' + 'that implements LiveState. Did you mean to remove the @live annotation on this resolver?', field.path) : invariant(false) : void 0;
          }
          var liveState =
          // $FlowFixMe[incompatible-type] - casting mixed
          evaluationResult.resolverResult;
          updatedDataIDs = this._setLiveStateValue(linkedRecord, linkedID, liveState, field, variables);
        } else {
          if (process.env.NODE_ENV !== "production") {
            var _evaluationResult$sna;
            !(evaluationResult.error != null || ((_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.isMissingData)) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected the @live Relay Resolver backing the field "%s" to return a value ' + 'that implements LiveState interface. The result for this field is `%s`, we also did not detect any errors, ' + 'or missing data during resolver execution. Did you mean to remove the @live annotation on this ' + 'resolver, or was there unexpected early return in the function?', field.path, String(evaluationResult.resolverResult)) : invariant(false) : void 0;
          }
        }
      } else {
        if (process.env.NODE_ENV !== "production") {
          !!isLiveStateValue(evaluationResult.resolverResult) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Unexpected LiveState value returned from the non-@live Relay Resolver backing the field "%s". Did you intend to add @live to this resolver?', field.path) : invariant(false) : void 0;
        }
        updatedDataIDs = this._setResolverValue(linkedRecord, evaluationResult.resolverResult, field, variables);
      }
      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);
      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);
      recordSource.set(linkedID, linkedRecord);

      // Link the resolver value record to the resolver field of the record being read:

      // Note: We get a fresh instance of the parent record from the record
      // source, because it may have been updated when we traversed into child
      // resolvers.
      var currentRecord = expectRecord(recordSource, recordID);
      var nextRecord = RelayModernRecord.clone(currentRecord);
      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);
      recordSource.set(recordID, nextRecord);
      if (field.fragment != null) {
        var _evaluationResult$sna2;
        // Put records observed by the resolver into the dependency graph:
        var fragmentStorageKey = getStorageKey(field.fragment, variables);
        var resolverID = generateClientID(recordID, fragmentStorageKey);
        addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);
        addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);
        var seenRecordIds = (_evaluationResult$sna2 = evaluationResult.snapshot) === null || _evaluationResult$sna2 === void 0 ? void 0 : _evaluationResult$sna2.seenRecords;
        if (seenRecordIds != null) {
          var _iterator = (0, _createForOfIteratorHelper2["default"])(seenRecordIds),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var seenRecordID = _step.value;
              addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      }
    } else if (field.kind === RELAY_LIVE_RESOLVER && RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY)) {
      var _linkedID2;
      // If this is an Live Resolver, we might have a cache hit (the
      // fragment data hasn't changed since we last evaluated the resolver),
      // but it might still be "dirty" (the live state changed and we need
      // to call `.read()` again).
      linkedID = (_linkedID2 = linkedID) !== null && _linkedID2 !== void 0 ? _linkedID2 : generateClientID(recordID, storageKey);
      linkedRecord = RelayModernRecord.clone(linkedRecord);
      // $FlowFixMe[incompatible-type] - casting mixed
      var _liveState = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
      if (!isLiveStateValue(_liveState)) {
        !false ? process.env.NODE_ENV !== "production" ? invariant(false, 'Unexpected LiveState value returned from Relay Resolver internal field `RELAY_RESOLVER_LIVE_STATE_VALUE`. ' + 'It is likely a bug in Relay, or a corrupt state of the relay store state ' + 'Field Path `%s`. Record `%s`.', field.path, JSON.stringify(linkedRecord)) : invariant(false) : void 0;
      }
      updatedDataIDs = this._setResolverValue(linkedRecord, _liveState.read(), field, variables);

      // Mark the resolver as clean again.
      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);
      recordSource.set(linkedID, linkedRecord);
    }

    // $FlowFixMe[incompatible-type] - will always be empty
    var answer = this._getResolverValue(linkedRecord);

    // $FlowFixMe[incompatible-type] - casting mixed
    var snapshot = linkedRecord[RELAY_RESOLVER_SNAPSHOT_KEY];
    // $FlowFixMe[incompatible-type] - casting mixed
    var error = linkedRecord[RELAY_RESOLVER_ERROR_KEY];
    var suspenseID = null;
    if (isSuspenseSentinel(answer)) {
      var _linkedID3;
      suspenseID = (_linkedID3 = linkedID) !== null && _linkedID3 !== void 0 ? _linkedID3 : generateClientID(recordID, storageKey);
    }
    return [answer, linkedID, error, snapshot, suspenseID, updatedDataIDs];
  };
  _proto.getLiveResolverPromise = function getLiveResolverPromise(liveStateID) {
    var recordSource = this._getRecordSource();
    var liveStateRecord = recordSource.get(liveStateID);
    !(liveStateRecord != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected to find record for live resolver.') : invariant(false) : void 0;

    // $FlowFixMe[incompatible-type] - casting mixed
    var liveState = RelayModernRecord.getValue(liveStateRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
    return new Promise(function (resolve) {
      var unsubscribe = liveState.subscribe(function () {
        unsubscribe();
        resolve();
      });
    });
  };
  _proto._maybeUnsubscribeFromLiveState = function _maybeUnsubscribeFromLiveState(linkedRecord) {
    // If there's an existing subscription, unsubscribe.
    // $FlowFixMe[incompatible-type] - casting mixed
    var previousUnsubscribe = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY);
    if (previousUnsubscribe != null) {
      previousUnsubscribe();
    }
  }

  // Register a new Live State object in the store, subscribing to future
  // updates.
  ;
  _proto._setLiveStateValue = function _setLiveStateValue(linkedRecord, linkedID, liveState, field, variables) {
    // Subscribe to future values
    // Note: We subscribe before reading, since subscribing could potentially
    // trigger a synchronous update. By reading a second way we will always
    // observe the new value, without needing to double render.
    var handler = this._makeLiveStateHandler(linkedID);
    var unsubscribe = liveState.subscribe(handler);

    // Store the live state value for future re-reads.
    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE, liveState);

    // Store the current value, for this read, and future cached reads.
    var updatedDataIDs = this._setResolverValue(linkedRecord, liveState.read(), field, variables);

    // Mark the field as clean.
    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);

    // Store our our unsubscribe function for future cleanup.
    RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY, unsubscribe);
    return updatedDataIDs;
  }

  // Create a callback to handle notifications from the live source that the
  // value may have changed.
  ;
  _proto._makeLiveStateHandler = function _makeLiveStateHandler(linkedID) {
    var _this = this;
    return function () {
      var currentSource = _this._getRecordSource();
      var currentRecord = currentSource.get(linkedID);
      if (!currentRecord) {
        // If there is no record yet, it means the subscribe function fired an
        // update synchronously on subscribe (before we even created the record).
        // In this case we can safely ignore this update, since we will be
        // reading the new value when we create the record.
        return;
      }
      if (!(RELAY_RESOLVER_LIVE_STATE_VALUE in currentRecord)) {
        process.env.NODE_ENV !== "production" ? warning(false, 'Unexpected callback for a incomplete live resolver record (__id: `%s`). The record has missing live state value. ' + 'This is a no-op and indicates a memory leak, and possible bug in Relay Live Resolvers. ' + 'Possible cause: The original record was GC-ed, or was created with the optimistic record source.' + ' Record details: `%s`.', linkedID, JSON.stringify(currentRecord)) : void 0;
        return;
      }
      var nextRecord = RelayModernRecord.clone(currentRecord);

      // Mark the field as dirty. The next time it's read, we will call
      // `LiveState.read()`.
      RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, true);
      _this._setLiveResolverUpdate(linkedID, nextRecord);
    };
  };
  _proto._setLiveResolverUpdate = function _setLiveResolverUpdate(linkedId, record) {
    if (this._handlingBatch) {
      // Lazily create the batched record source.
      if (this._liveResolverBatchRecordSource == null) {
        this._liveResolverBatchRecordSource = RelayRecordSource.create();
      }
      this._liveResolverBatchRecordSource.set(linkedId, record);
      // We will wait for the batch to complete before we publish/notify...
    } else {
      var nextSource = RelayRecordSource.create();
      nextSource.set(linkedId, record);

      // We are not within a batch, so we will immediately publish/notify.
      this._store.publish(nextSource);
      this._store.notify();
    }
  };
  _proto.batchLiveStateUpdates = function batchLiveStateUpdates(callback) {
    !!this._handlingBatch ? process.env.NODE_ENV !== "production" ? invariant(false, 'Unexpected nested call to batchLiveStateUpdates.') : invariant(false) : void 0;
    this._handlingBatch = true;
    try {
      callback();
    } finally {
      // We lazily create the record source. If one has not been created, there
      // is nothing to publish.
      if (this._liveResolverBatchRecordSource != null) {
        this._store.publish(this._liveResolverBatchRecordSource);
        this._store.notify();
      }

      // Reset batched state.
      this._liveResolverBatchRecordSource = null;
      this._handlingBatch = false;
    }
  };
  _proto._setResolverValue = function _setResolverValue(resolverRecord, value, field, variables) {
    var normalizationInfo = field.normalizationInfo;
    var updatedDataIDs = null;
    if (value != null && normalizationInfo != null) {
      var resolverValue;
      var prevOutputTypeRecordIDs = getOutputTypeRecordIDs(resolverRecord);
      var nextOutputTypeRecordIDs = new Set();
      var currentSource = this._getRecordSource();
      if (normalizationInfo.plural) {
        !Array.isArray(value) ? process.env.NODE_ENV !== "production" ? invariant(false, '_setResolverValue: Expected array value for plural @outputType resolver.') : invariant(false) : void 0;

        // For plural resolvers we will be returning
        // the list of generated @outputType record `ID`s.
        resolverValue = [];
        var nextSource = RelayRecordSource.create();
        for (var ii = 0; ii < value.length; ii++) {
          var currentValue = value[ii];
          if (currentValue == null) {
            continue;
          }
          !(typeof currentValue == 'object') ? process.env.NODE_ENV !== "production" ? invariant(false, '_setResolverValue: Expected object value as the payload for the @outputType resolver.') : invariant(false) : void 0;
          // The `id` of the nested object (@outputType resolver)
          // is localized to it's resolver record. To ensure that
          // there is only one path to the records created from the
          // @outputType payload.

          var typename = getConcreteTypename(normalizationInfo, currentValue);
          var outputTypeDataID = generateClientObjectClientID(typename, RelayModernRecord.getDataID(resolverRecord), ii);
          var source = normalizeOutputTypeValue(outputTypeDataID, currentValue, variables, normalizationInfo, this._store.__getNormalizationOptions([field.path, String(ii)]), typename);
          var _iterator2 = (0, _createForOfIteratorHelper2["default"])(source.getRecordIDs()),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var recordID = _step2.value;
              // For plural case we'll keep adding the `item` records to the `nextSource`
              // so we can publish all of them at the same time: clean up all records,
              // and correctly collect all `dirty` records.
              nextSource.set(recordID, expectRecord(source, recordID));
              nextOutputTypeRecordIDs.add(recordID);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          resolverValue.push(outputTypeDataID);
        }

        // Adding/removing/updating records in the `currentSource`.
        updatedDataIDs = updateCurrentSource(currentSource, nextSource, prevOutputTypeRecordIDs);
      } else {
        !(typeof value == 'object') ? process.env.NODE_ENV !== "production" ? invariant(false, '_setResolverValue: Expected object value as the payload for the @outputType resolver.') : invariant(false) : void 0;
        var _typename = getConcreteTypename(normalizationInfo, value);
        var _outputTypeDataID = generateClientObjectClientID(_typename, RelayModernRecord.getDataID(resolverRecord));
        var _nextSource = normalizeOutputTypeValue(_outputTypeDataID, value, variables, normalizationInfo, this._store.__getNormalizationOptions([field.path]), _typename);
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(_nextSource.getRecordIDs()),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _recordID = _step3.value;
            nextOutputTypeRecordIDs.add(_recordID);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        resolverValue = _outputTypeDataID;
        updatedDataIDs = updateCurrentSource(currentSource, _nextSource, prevOutputTypeRecordIDs);
      }

      // Keep track of the created record IDs from this resolver
      // so we can properly clean them, if they are no longer used.
      RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, nextOutputTypeRecordIDs);
      RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY, resolverValue);
    } else {
      // For "classic" resolvers (or if the value is nullish), we are just setting their
      // value as is.
      RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY, value);
    }
    return updatedDataIDs;
  };
  _proto.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {
    this._store.__notifyUpdatedSubscribers(updatedDataIDs);
  };
  _proto._getResolverValue = function _getResolverValue(resolverRecord) {
    return RelayModernRecord.getValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY);
  };
  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs // Mutated in place
  ) {
    var recordSource = this._getRecordSource();
    var visited = new Set();
    var recordsToVisit = Array.from(updatedDataIDs);
    while (recordsToVisit.length) {
      var recordID = recordsToVisit.pop();
      updatedDataIDs.add(recordID);
      var fragmentSet = this._recordIDToResolverIDs.get(recordID);
      if (fragmentSet == null) {
        continue;
      }
      var _iterator4 = (0, _createForOfIteratorHelper2["default"])(fragmentSet),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var fragment = _step4.value;
          if (!visited.has(fragment)) {
            var recordSet = this._resolverIDToRecordIDs.get(fragment);
            if (recordSet == null) {
              continue;
            }
            var _iterator5 = (0, _createForOfIteratorHelper2["default"])(recordSet),
              _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var anotherRecordID = _step5.value;
                this._markInvalidatedResolverRecord(anotherRecordID, recordSource);
                if (!visited.has(anotherRecordID)) {
                  recordsToVisit.push(anotherRecordID);
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
  };
  _proto._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource // Written to
  ) {
    var record = recordSource.get(dataID);
    if (!record) {
      process.env.NODE_ENV !== "production" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;
      return;
    }
    var nextRecord = RelayModernRecord.clone(record);
    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);
    recordSource.set(dataID, nextRecord);
  };
  _proto._isInvalid = function _isInvalid(record, getDataForResolverFragment) {
    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {
      return false;
    }
    // $FlowFixMe[incompatible-type] - storing values in records is not typed
    var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);
    var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;
    var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;
    if (originalInputs == null || readerSelector == null) {
      process.env.NODE_ENV !== "production" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;
      return true;
    }
    var _getDataForResolverFr = getDataForResolverFragment(readerSelector),
      latestValues = _getDataForResolverFr.data;
    var recycled = recycleNodesInto(originalInputs, latestValues);
    if (recycled !== originalInputs) {
      return true;
    }
    return false;
  }

  // If a given record does not exist, creates an empty record consisting of
  // just an `id` field, along with a namespaced `__id` field and insert it into
  // the store.
  ;
  _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
    var key = generateClientObjectClientID(typeName, id);
    var recordSource = this._getRecordSource();
    if (!recordSource.has(key)) {
      var newRecord = RelayModernRecord.create(key, typeName);
      RelayModernRecord.setValue(newRecord, 'id', id);
      recordSource.set(key, newRecord);
    }
    return key;
  };
  _proto.unsubscribeFromLiveResolverRecords = function unsubscribeFromLiveResolverRecords(invalidatedDataIDs) {
    if (invalidatedDataIDs.size === 0) {
      return;
    }
    var _iterator6 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var dataID = _step6.value;
        var record = this._getRecordSource().get(dataID);
        if (record != null && RelayModernRecord.getType(record) === RELAY_RESOLVER_RECORD_TYPENAME) {
          this._maybeUnsubscribeFromLiveState(record);
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
  }

  // Given the set of possible invalidated DataID
  // (Example may be: records from the reverted optimistic update)
  // this method will remove resolver records from the store,
  // which will force a reader to re-evaluate the value of this field.
  ;
  _proto.invalidateResolverRecords = function invalidateResolverRecords(invalidatedDataIDs) {
    if (invalidatedDataIDs.size === 0) {
      return;
    }
    var _iterator7 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var dataID = _step7.value;
        var record = this._getRecordSource().get(dataID);
        if (record != null && RelayModernRecord.getType(record) === RELAY_RESOLVER_RECORD_TYPENAME) {
          this._getRecordSource()["delete"](dataID);
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  };
  return LiveResolverCache;
}(); // Returns a normalized version (RecordSource) of the @outputType,
// containing only "weak" records.
function normalizeOutputTypeValue(outputTypeDataID, value, variables, resolverNormalizationInfo, normalizationOptions, typename) {
  var source = RelayRecordSource.create();
  source.set(outputTypeDataID, RelayModernRecord.create(outputTypeDataID, typename));
  var selector = createNormalizationSelector(resolverNormalizationInfo.normalizationNode, outputTypeDataID, variables);

  // The resulted `source` is the normalized version of the
  // resolver's (@outputType) value.
  // All records in the `source` should have IDs that
  // is "prefix-ed" with the parent resolver record `ID`
  // and they don't expect to have a "strong" identifier.
  return normalize(source, selector, value, normalizationOptions).source;
}

// Update the `currentSource` with the set of new records from the
// resolver with @outputType.
// This method will return a set of `updatedDataIDs` IDs.
// The record is marked as `updated`, if
// - it is removed from the current source
// - it is updated in the current source
// A record is **not** marked as `updated` if it is only added to the current source.
function updateCurrentSource(currentSource, nextSource, prevOutputTypeRecordIDs) {
  var updatedDataIDs = new Set();

  // First, we are removing records from the `currentSource`
  // that is no longer created from the resolver with @outputType
  // (these are new records in the `nextSource`).
  if (prevOutputTypeRecordIDs != null) {
    var _iterator8 = (0, _createForOfIteratorHelper2["default"])(prevOutputTypeRecordIDs),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var recordID = _step8.value;
        if (!nextSource.has(recordID)) {
          updatedDataIDs.add(recordID);
          currentSource.remove(recordID);
        }
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
  }

  // Next, we are updating records in the `currentSource` with the
  // new values from the `nextSource`. If the record has change we're adding its
  // `id` to the set of `updatedDataIDs`.
  // New records are just added to the `currentSource`, we do not add their
  // ids to the `updatedDataIDs` set, as there shouldn't be any subscribers
  // for these.
  var _iterator9 = (0, _createForOfIteratorHelper2["default"])(nextSource.getRecordIDs()),
    _step9;
  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _recordID2 = _step9.value;
      var nextRecord = expectRecord(nextSource, _recordID2);
      if (currentSource.has(_recordID2)) {
        var currentRecord = expectRecord(currentSource, _recordID2);
        var updatedRecord = RelayModernRecord.update(currentRecord, nextRecord);
        if (updatedRecord !== currentRecord) {
          updatedDataIDs.add(_recordID2);
          currentSource.set(_recordID2, nextRecord);
        }
      } else {
        currentSource.set(_recordID2, nextRecord);
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
  return updatedDataIDs;
}
function expectRecord(source, recordID) {
  var record = source.get(recordID);
  !(record != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'Expected a record with ID `%s` to exist in the record source.', recordID) : invariant(false) : void 0;
  return record;
}
function getUpdatedDataIDs(updatedRecords) {
  return updatedRecords;
}
function getConcreteTypename(normalizationInfo, currentValue) {
  var _normalizationInfo$co;
  // If normalizationInfo does not have a concrete type (i.e. the return type of the resolver
  // is abstract), then the generated return type for the resolver will include a mandatory
  // __typename field.
  var typename = (_normalizationInfo$co = normalizationInfo.concreteType) !== null && _normalizationInfo$co !== void 0 ? _normalizationInfo$co :
  // $FlowFixMe[prop-missing]
  currentValue.__typename;
  !(typename != null) ? process.env.NODE_ENV !== "production" ? invariant(false, 'normalizationInfo.concreteType should not be null, or the value returned from the resolver should include a __typename field, ' + 'or the resolver should have a flow error. If not, this indicates a bug in Relay.') : invariant(false) : void 0;
  return typename;
}
module.exports = {
  LiveResolverCache: LiveResolverCache,
  getUpdatedDataIDs: getUpdatedDataIDs
};